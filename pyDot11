#!/usr/bin/python2.7

import argparse, os, subprocess, sys
from scapy.sendrecv import sniff
from scapy.layers.inet import IP
from scapy.sendrecv import sendp, sniff
from scapy.layers.l2 import Ether, EAPOL
from pyDot11 import *

def fromDecrypt(packet, args, *cryptoList):
    """Encompass steps for From-DS decrypt"""
    if args.t == 'wep':
        decodedPkt, iv = wepDecrypt(packet, args.p, False)
    else:
        tk = cryptoList[0].tgtInfo.get(cryptoList[3])[0]
        encKey = cryptoList[0].tgtInfo.get(cryptoList[3])[1]
        if cryptoList[0].encDict.get(cryptoList[3]) == 'ccmp':
            origPkt, decodedPkt, PN = wpaDecrypt(encKey, packet, 'ccmp')
        else:
            origPkt, decodedPkt, PN = wpaDecrypt(tk, packet, 'tkip')

    ### Debate on changing this so we push all?
    if decodedPkt.haslayer(IP):
        sendp(Ether(src = packet[Dot11].addr3,
                    dst = packet[Dot11].addr1,
                    type = 0x800)/decodedPkt[IP],
        iface = 'tap{0}'.format(args.n),
        verbose = 0)


def toDecrypt(packet, args, *cryptoList):
    """Encompass steps for To-DS decrypt"""
    ## DEBUG
    #if args.v:
        #startDecrypt = time.time()

    if args.t == 'wep':
        decodedPkt, iv = wepDecrypt(packet, args.p, False)
    else:
        tk = cryptoList[0].tgtInfo.get(cryptoList[3])[0]
        encKey = cryptoList[0].tgtInfo.get(cryptoList[3])[1]
        if cryptoList[0].encDict.get(cryptoList[3]) == 'ccmp':
            origPkt, decodedPkt, PN = wpaDecrypt(encKey, packet, 'ccmp')
        else:
            origPkt, decodedPkt, PN = wpaDecrypt(tk, packet, 'tkip')

    ### Debate on changing this so we push all?
    if decodedPkt.haslayer(IP):
        sendp(Ether(src = packet[Dot11].addr2,
                    dst = packet[Dot11].addr3,
                    type = 0x800)/decodedPkt[IP],
        iface = 'tap{0}'.format(args.n),
        verbose = 0)
        

def pktFilter(packet):
    """ Verify it is an encrypted data packet"""
    if packet[Dot11].type == 2 and\
       packet.haslayer(Dot11WEP) and\
       (packet[Dot11].FCfield == 65l or packet[Dot11].FCfield == 66L):
        return True
    else:
        return False


def wepParser(args):
    def engine(packet):

        ## Verify we care
        if pktFilter(packet):
            
            ## Both ways From-DS
            if args.d == 'both' and packet[Dot11].addr2 == args.b.lower():
                fromDecrypt(packet, args)
                
            ## Both ways To-DS
            elif args.d == 'both' and packet[Dot11].addr1 == args.b.lower():
                toDecrypt(packet, args)

            # From-DS
            elif args.d == 'from' and packet[Dot11].addr2 == args.b.lower():
                fromDecrypt(packet, args)

            # To-DS
            elif args.d == 'to' and packet[Dot11].addr1 == args.b.lower():
                toDecrypt(packet, args)

    return engine


### Need to verify chksums and src/dst for Ether()
def wpaParser(args, shake, ccmp, tkip):
    def engine(packet):
        try:
            if packet.haslayer(EAPOL):
                shake.eapolGrab(packet)
                
            ## Verify we care
            elif pktFilter(packet):
                tgtMAC = False
                
                ## DEBUG
                #print shake.availTgts
                
                ## MAC verification
                if packet.addr1 in shake.availTgts:
                    tgtMAC = packet.addr1
                elif packet.addr2 in shake.availTgts:
                    tgtMAC = packet.addr2

                ## DEBUG
                #print 'My tgtMAC is: %s' % tgtMAC

                if tgtMAC:

                    ## Both ways From-DS
                    if args.d == 'both' and packet[Dot11].addr2 == args.b.lower():
                        fromDecrypt(packet, args, shake, ccmp, tkip, tgtMAC)
                        
                    ## Both ways To-DS
                    elif args.d == 'both' and packet[Dot11].addr1 == args.b.lower():
                        toDecrypt(packet, args, shake, ccmp, tkip, tgtMAC)

                    # From-DS
                    elif args.d == 'from' and packet[Dot11].addr2 == args.b.lower():
                        fromDecrypt(packet, args, shake, ccmp, tkip, tgtMAC)

                    # To-DS
                    elif args.d == 'to' and packet[Dot11].addr1 == args.b.lower():
                        toDecrypt(packet, args, shake, ccmp, tkip, tgtMAC)
                else:
                    pass
            else:
                pass
        except:
            pass
    return engine


def main(args):

    ## Setup the tap
    if not args.n:
        dev = Tap()
        subprocess.check_call('ifconfig tap0 up'.format(args.n), shell = True)
        args.n = 0
    else:
        dev = Tap(args.n)
        subprocess.check_call('ifconfig tap{0} up'.format(args.n), shell = True)

    ## Setup the encryption
    if args.t == 'wep':
        packetParser = wepParser(args)
    if args.t == 'wpa':
        if not args.e:
            print 'wpa requires -e'
            sys.exit(1)
        ccmp = Ccmp()
        tkip = Tkip()
        shake = Handshake(args.p, args.e)
        packetParser = wpaParser(args, shake, ccmp, tkip)

    print 'pyDot11 up and running on tap{0}'.format(args.n)

    ## Default direction of To-DS
    if not args.d or args.d == 'to':
        if not args.d:
            args.d = 'to'
        if args.t == 'wpa':
            lfilter = lambda x: x[Dot11].FCfield == 65L or x.haslayer(EAPOL)
        else:
            lfilter = lambda x: x[Dot11].FCfield == 65L

    ## Deal with 2-way
    elif args.d == 'both':
        if args.t == 'wpa':
            lfilter = lambda x: x[Dot11].FCfield == 65L or x[Dot11].FCfield == 66L or x.haslayer(EAPOL)
        else:
            lfilter = lambda x: x[Dot11].FCfield == 65L or x[Dot11].FCfield == 66L

    ## Deal with From-DS
    elif args.d == 'from':
        if args.t == 'wpa':
            lfilter = lambda x: x[Dot11].FCfield == 66L or x.haslayer(EAPOL)
        else:
            lfilter = lambda x: x[Dot11].FCfield == 66L

    sniff(iface = args.i, prn = packetParser, lfilter = lfiter, store = 0)



if __name__ == '__main__':
    parser = argparse.ArgumentParser(description = 'pyDot11 - Encrypt and Decrypt 802.11 on-the-fly')

    parser.add_argument('-b',
                        metavar = '<tgt BSSID>',
                        required = True,
                        help = 'Target BSSID ---------------------- required')
    parser.add_argument('-d',
                        choices = ['both', 'from', 'to'],
                        metavar = '<Direction>',
                        help = 'Direction -------------------- [Default: to]')
    parser.add_argument('-e',
                        metavar = '<tgt ESSID>',
                        help = 'Target ESSID -------------- required for wpa')
    parser.add_argument('-i',
                        metavar = '<Sniffing NIC>',
                        required = True,
                        help = 'NIC to sniff with ----------------- required')
    parser.add_argument('-n',
                        metavar = '<dev number>',
                        help = 'Device number for Tap interface [Default: 0]')
    parser.add_argument('-p',
                        metavar = '<Passphrase>',
                        required = True,
                        help = 'Target passphrase ----------------- required')
    parser.add_argument('-t',
                        choices = ['wep', 'wpa'],
                        metavar = '<Encryption type>',
                        required = True,
                        help = 'Encryption type ------------------- required')
    args = parser.parse_args()
    main(args)
